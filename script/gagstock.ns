const fs = require("fs-extra");
const path = require("path");
const moment = require("moment-timezone");

const dataDir = path.join(__dirname, "gardens");
const stockFile = path.join(__dirname, "stock.json");
fs.ensureDirSync(dataDir);

let stock = { fruits: 100 };
try {
  if (fs.existsSync(stockFile)) {
    stock = JSON.parse(fs.readFileSync(stockFile, "utf-8"));
  }
} catch {
  console.log("âš ï¸ Failed to load stock.json. Using default.");
}

function saveStock() {
  fs.writeFileSync(stockFile, JSON.stringify(stock, null, 2));
}

function getPHTime() {
  return moment().tz("Asia/Manila").format("MMMM Do YYYY, h:mm:ss A");
}

function box(txt) {
  return `â•­â”€â’\n${txt}\nâ•°â”€â”€â”€â”€`;
}

const shop = {
  apple: { emoji: "ğŸ", price: 40, type: "seed" },
  melon: { emoji: "ğŸˆ", price: 60, type: "seed" },
  chili: { emoji: "ğŸŒ¶ï¸", price: 55, type: "seed" },
  wateringcan: { emoji: "ğŸ’§", price: 120, type: "gear" },
  shovel: { emoji: "ğŸ› ï¸", price: 150, type: "gear" },
  hat: { emoji: "ğŸ©", price: 200, type: "cosmetic" },
  glasses: { emoji: "ğŸ•¶ï¸", price: 180, type: "cosmetic" }
};

const stages = [
  "ğŸŸ« Soil ready",
  "ğŸŒ± Seed planted",
  "ğŸ’§ Watered",
  "ğŸŒ¿ Sprouting",
  "ğŸŒ¸ Blooming",
  "ğŸŒ» Fully grown"
];

const landPrice = { 1: 100, 5: 450, 10: 800 };
const adminID = "YOUR_ADMIN_ID"; // <-- set this
const groupIDs = ["24019705744313315"];

async function loadUser(id) {
  const file = path.join(dataDir, `${id}.json`);
  if (await fs.pathExists(file)) {
    const d = await fs.readJson(file);
    d.inventory ??= {};
    d.gear ??= {};
    d.cosmetics ??= {};
    d.equipped ??= null;
    d.coins ??= 100;
    d.land ??= { total: 1, used: 0 };
    d.plant ??= null;
    d.lastClaim ??= 0;
    d.autoHarvest ??= false;
    return d;
  }
  return {
    inventory: {},
    gear: {},
    cosmetics: {},
    equipped: null,
    coins: 100,
    land: { total: 1, used: 0 },
    plant: null,
    lastClaim: 0,
    autoHarvest: false
  };
}

async function saveUser(id, data) {
  const file = path.join(dataDir, `${id}.json`);
  await fs.writeJson(file, data);
}

module.exports.config = {
  name: "putikgagstock",
  version: "7.9.0",
  hasPermission: 0,
  usePrefix: true,
  description: "Extended garden + stock system",
  usages: "[commands]",
  cooldowns: 1
};

module.exports.run = async function ({ api, event, args }) {
  const { threadID, senderID, senderName, messageID } = event;
  const cmd = args[0]?.toLowerCase();
  const user = await loadUser(senderID);

  if (!cmd) {
    return api.sendMessage(
      box(`ğŸŒ± Garden Commands:
- claim
- shop
- buy <item>
- inventory
- plant <seed>
- water
- grow
- harvest
- buyland <qty>
- equip <cosmetic>
- autoharvest on/off
(Admin) resetall`),
      threadID
    );
  }

  // CLAIM
  if (cmd === "claim") {
    const now = Date.now();
    if (now - user.lastClaim < 86400000)
      return api.sendMessage("â³ Claim every 24h only.", threadID);
    user.coins += 50000;
    user.lastClaim = now;
    await saveUser(senderID, user);
    return api.sendMessage(`âœ… You claimed 50,000 coins.\nğŸ•’ ${getPHTime()}`, threadID);
  }

  // SHOP
  if (cmd === "shop") {
    let msg = "ğŸ›’ Shop:\n";
    for (const [key, item] of Object.entries(shop)) {
      msg += `${item.emoji} ${key} â€” ğŸ’° ${item.price}\n`;
    }
    return api.sendMessage(box(msg), threadID);
  }

  // BUY
  if (cmd === "buy") {
    const item = args[1]?.toLowerCase();
    if (!shop[item]) return api.sendMessage("âŒ Invalid item.", threadID);
    if (user.coins < shop[item].price) return api.sendMessage("âŒ Not enough coins.", threadID);
    user.coins -= shop[item].price;
    if (shop[item].type === "cosmetic") {
      user.cosmetics[item] = (user.cosmetics[item] || 0) + 1;
    } else if (shop[item].type === "gear") {
      user.gear[item] = (user.gear[item] || 0) + 1;
    } else {
      user.inventory[item] = (user.inventory[item] || 0) + 1;
    }
    await saveUser(senderID, user);
    return api.sendMessage(`âœ… Bought ${shop[item].emoji} ${item}`, threadID);
  }

  // INVENTORY
  if (cmd === "inventory") {
    let msg = `ğŸ’° Coins: ${user.coins}\nğŸ¡ Land: ${user.land.used}/${user.land.total}\n`;
    msg += `ğŸ¨ Equipped: ${user.equipped || "None"}\n\nğŸ“¦ Seeds:\n`;
    for (const [k, v] of Object.entries(user.inventory)) {
      msg += `- ${k}: ${v}\n`;
    }
    msg += `\nğŸ› ï¸ Gear:\n`;
    for (const [k, v] of Object.entries(user.gear)) {
      msg += `- ${k}: ${v}\n`;
    }
    msg += `\nğŸ¨ Cosmetics:\n`;
    for (const [k, v] of Object.entries(user.cosmetics)) {
      msg += `- ${k}: ${v}\n`;
    }
    return api.sendMessage(box(msg), threadID);
  }

  // EQUIP
  if (cmd === "equip") {
    const item = args[1]?.toLowerCase();
    if (!user.cosmetics[item]) return api.sendMessage("âŒ You don't own that cosmetic.", threadID);
    user.equipped = item;
    await saveUser(senderID, user);
    return api.sendMessage(`ğŸ¨ You equipped ${shop[item].emoji} ${item}`, threadID);
  }

  // PLANT
  if (cmd === "plant") {
    const seed = args[1]?.toLowerCase();
    if (!user.inventory[seed]) return api.sendMessage("âŒ You don't have that seed.", threadID);
    if (user.land.used >= user.land.total) return api.sendMessage("âŒ No free land.", threadID);
    user.inventory[seed]--;
    user.plant = { name: seed, stage: 0, watered: false };
    user.land.used++;
    await saveUser(senderID, user);
    return api.sendMessage(`ğŸŒ± Planted ${shop[seed].emoji} ${seed}`, threadID);
  }

  // WATER
  if (cmd === "water") {
    if (!user.plant) return api.sendMessage("âŒ No plant to water.", threadID);
    if (user.plant.watered) return api.sendMessage("ğŸ’§ Already watered.", threadID);
    user.plant.watered = true;
    await saveUser(senderID, user);
    return api.sendMessage(`ğŸ’§ Watered ${user.plant.name}`, threadID);
  }

  // GROW
  if (cmd === "grow") {
    if (!user.plant) return api.sendMessage("âŒ No plant.", threadID);
    if (!user.plant.watered) return api.sendMessage("ğŸ’§ Water your plant first.", threadID);
    if (user.plant.stage >= stages.length - 1)
      return api.sendMessage("ğŸŒ» Fully grown! Use harvest.", threadID);
   
